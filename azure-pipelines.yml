# Azure DevOps Pipeline for Backend Application
# Build and push Docker image to ACR

name: Backend-Build-$(Date:yyyyMMdd)-$(Rev:r)

trigger:
  branches:
    include:
    - main
    - develop
  paths:
    exclude:
    - README.md
    - docs/*
    - '*.md'

variables:
  # Version configuration
  majorVersion: 1
  minorVersion: 0
  patchVersion: '$(Build.BuildId)'
  branchName: '$(Build.SourceBranchName)'
  
  # Azure Container Registry
  containerRegistry: 'acrServiceConnection'  # Update this to match your ACR service connection name
  imageRepository: 'backend'
  dockerfilePath: 'Dockerfile'

stages:
- stage: Build
  displayName: 'Build and Push Backend'
  jobs:
  - job: BuildBackend
    displayName: 'Build Backend Application'
    pool:
      name: 'Default'  # Use Default agent pool (or your custom pool name)
      demands:
      - agent.name -equals THINHPC  # Optional: specify exact agent
    steps:
    - checkout: self
      displayName: 'Checkout backend source'
    
    - task: PowerShell@2
      displayName: 'Set Version Tags'
      inputs:
        targetType: 'inline'
        script: |
          $branchName = "$(Build.SourceBranchName)"
          $versionedTag = "v$(majorVersion).$(minorVersion).$(patchVersion)"
          $latestTag = ""
          
          Write-Host "Branch: $branchName"
          Write-Host "Versioned tag: $versionedTag"
          
          # Set tags based on branch
          if ($branchName -eq "main") {
            $latestTag = "latest"
            Write-Host "##vso[task.setvariable variable=versionedTag]$versionedTag"
            Write-Host "##vso[task.setvariable variable=latestTag]$latestTag"
            Write-Host "Tags will be: $versionedTag, $latestTag"
          } elseif ($branchName -eq "develop") {
            $devTag = "dev-v$(majorVersion).$(minorVersion).$(patchVersion)"
            Write-Host "##vso[task.setvariable variable=versionedTag]$versionedTag"
            Write-Host "##vso[task.setvariable variable=latestTag]$devTag"
            Write-Host "Tags will be: $versionedTag, $devTag"
          } else {
            Write-Host "##vso[task.setvariable variable=versionedTag]$versionedTag"
            Write-Host "##vso[task.setvariable variable=latestTag]"
            Write-Host "Tags will be: $versionedTag"
          }
          
    - task: NodeTool@0
      displayName: 'Setup Node.js'
      inputs:
        versionSpec: '18.x'
        
    - task: PowerShell@2
      displayName: '[MOCK] Install dependencies and run tests'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "[MOCK] Installing dependencies..."
          Write-Host "‚úÖ Dependencies would be installed via: npm ci"
          Write-Host ""
          Write-Host "[MOCK] Running tests..."
          Write-Host "‚úÖ Backend tests would run via: npm run test"
          Write-Host "   - Unit tests: ‚úÖ Passed"
          Write-Host "   - Integration tests: ‚úÖ Passed"
          Write-Host ""
          Write-Host "[MOCK] Running security audit..."
          Write-Host "‚úÖ Security audit would run via: npm audit --audit-level high"
          Write-Host "   - No vulnerabilities found"
        workingDirectory: '$(Build.SourcesDirectory)'
      
    - task: Docker@2
      displayName: 'Build Docker image'
      inputs:
        containerRegistry: '$(containerRegistry)'
        repository: '$(imageRepository)'
        command: 'build'
        Dockerfile: '$(dockerfilePath)'
        buildContext: '$(Build.SourcesDirectory)'
        tags: |
          $(versionedTag)
          $(latestTag)

    - task: PowerShell@2
      displayName: 'Install Trivy'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Installing Trivy..."
          # Download and install Trivy
          $trivyVersion = "0.46.0"
          $downloadUrl = "https://github.com/aquasecurity/trivy/releases/download/v$trivyVersion/trivy_$($trivyVersion)_Windows-64bit.zip"
          $tempPath = "$env:TEMP\trivy.zip"
          $extractPath = "$env:TEMP\trivy"
          
          try {
            Invoke-WebRequest -Uri $downloadUrl -OutFile $tempPath
            Expand-Archive -Path $tempPath -DestinationPath $extractPath -Force
            $trivyPath = "$extractPath\trivy.exe"
            
            if (Test-Path $trivyPath) {
              Write-Host "‚úÖ Trivy installed successfully"
              Write-Host "##vso[task.setvariable variable=trivyPath]$trivyPath"
            } else {
              Write-Host "‚ùå Failed to install Trivy"
              exit 1
            }
          } catch {
            Write-Host "‚ùå Error installing Trivy: $_"
            exit 1
          }

    - task: PowerShell@2
      displayName: 'Security Scan with Trivy'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "üîç Running Trivy security scan on backend image..."
          $imageName = "$(imageRepository):$(versionedTag)"
          $trivyExe = "$(trivyPath)"
          
          Write-Host "Using Trivy executable: $trivyExe"
          Write-Host "Scanning image: $imageName"
          
          try {
            # First, update Trivy database
            Write-Host "üì• Updating Trivy vulnerability database..."
            $updateOutput = & $trivyExe image --download-db-only 2>&1
            Write-Host "Database update completed."
            
            # Run Trivy scan with proper error handling
            Write-Host "üîç Starting vulnerability scan..."
            
            # Create temp file for output
            $tempFile = "$env:TEMP\trivy-results.json"
            
            # Run scan and capture both stdout and stderr
            $process = Start-Process -FilePath $trivyExe -ArgumentList @(
              "image", 
              "--format", "json", 
              "--severity", "CRITICAL,HIGH,MEDIUM,LOW",
              "--output", $tempFile,
              $imageName
            ) -Wait -PassThru -NoNewWindow -RedirectStandardError "$env:TEMP\trivy-error.log"
            
            $scanExitCode = $process.ExitCode
            Write-Host "Trivy scan process completed with exit code: $scanExitCode"
            
            # Read results from file
            if (Test-Path $tempFile) {
              $trivyOutput = Get-Content -Path $tempFile -Raw
              
              if ($trivyOutput) {
                # Parse and display results
                $results = $trivyOutput | ConvertFrom-Json
                $criticalCount = 0
                $highCount = 0
                $mediumCount = 0
                $lowCount = 0
                
                if ($results.Results) {
                  foreach ($result in $results.Results) {
                    if ($result.Vulnerabilities) {
                      foreach ($vuln in $result.Vulnerabilities) {
                        switch ($vuln.Severity) {
                          "CRITICAL" { $criticalCount++ }
                          "HIGH" { $highCount++ }
                          "MEDIUM" { $mediumCount++ }
                          "LOW" { $lowCount++ }
                        }
                      }
                    }
                  }
                }
                
                Write-Host ""
                Write-Host "üõ°Ô∏è Security Scan Summary:"
                Write-Host "   üî¥ Critical: $criticalCount"
                Write-Host "   üü† High: $highCount"
                Write-Host "   üü° Medium: $mediumCount"
                Write-Host "   üü¢ Low: $lowCount"
                Write-Host ""
                
                if ($criticalCount -gt 0) {
                  Write-Host "‚ö†Ô∏è WARNING: $criticalCount critical vulnerabilities found in backend image!"
                  Write-Host "üîç Please review and address critical vulnerabilities when possible."
                  
                  # Generate detailed report for critical vulnerabilities
                  Write-Host ""
                  Write-Host "üìã Critical Vulnerabilities Details:"
                  foreach ($result in $results.Results) {
                    if ($result.Vulnerabilities) {
                      foreach ($vuln in $result.Vulnerabilities) {
                        if ($vuln.Severity -eq "CRITICAL") {
                          Write-Host "   - $($vuln.VulnerabilityID): $($vuln.Title)"
                          Write-Host "     Package: $($vuln.PkgName) ($($vuln.InstalledVersion))"
                          if ($vuln.FixedVersion) {
                            Write-Host "     Fix Available: $($vuln.FixedVersion)"
                          }
                          Write-Host ""
                        }
                      }
                    }
                  }
                } else {
                  Write-Host "‚úÖ No critical vulnerabilities found in backend image."
                }
              } else {
                Write-Host "‚ö†Ô∏è Warning: Trivy scan completed but no results found."
              }
              
              # Clean up temp file
              Remove-Item -Path $tempFile -ErrorAction SilentlyContinue
            } else {
              Write-Host "‚ö†Ô∏è Warning: Trivy results file not found."
            }
            
            # Show any errors if they exist
            if (Test-Path "$env:TEMP\trivy-error.log") {
              $errorContent = Get-Content -Path "$env:TEMP\trivy-error.log" -Raw
              if ($errorContent) {
                Write-Host "üìù Trivy process messages:"
                Write-Host $errorContent
              }
              Remove-Item -Path "$env:TEMP\trivy-error.log" -ErrorAction SilentlyContinue
            }
            
          } catch {
            Write-Host "‚ö†Ô∏è Warning: Error during Trivy scan: $_"
            Write-Host "This is a non-critical error. Pipeline will continue."
          }
          
          # Always continue - don't fail the pipeline
          Write-Host "‚úÖ Security scan completed. Pipeline will continue regardless of findings."
      continueOnError: true
          
    - task: Docker@2
      displayName: 'Push image to ACR'
      inputs:
        containerRegistry: '$(containerRegistry)'
        repository: '$(imageRepository)'
        command: 'push'
        tags: |
          $(versionedTag)
          $(latestTag)
          
    - task: PowerShell@2
      displayName: 'Build Summary'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "‚úÖ Backend build completed successfully!"
          Write-Host "üì¶ Images created:"
          Write-Host "   - $(imageRepository):$(versionedTag)"
          if ("$(latestTag)" -ne "") {
            Write-Host "   - $(imageRepository):$(latestTag)"
          }
          Write-Host "üîó Registry: ACR"
          Write-Host "üåø Branch: $(branchName)"
          Write-Host "üè∑Ô∏è Version: $(majorVersion).$(minorVersion).$(patchVersion)"